<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess Battle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        #info h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #status {
            font-size: 14px;
            margin: 10px 0;
            color: #4ecdc4;
        }
        #moves {
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .move {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #4ecdc4;
            padding-left: 10px;
        }
        button {
            margin-top: 10px;
            padding: 10px 20px;
            background: #4ecdc4;
            border: none;
            border-radius: 5px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45b7aa;
        }
        #controls {
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h1>♟️ AI Chess Battle</h1>
        <div id="status">Initializing...</div>
        <div id="controls">
            <button id="startBtn">Start Battle</button>
            <button id="resetBtn">Reset Game</button>
        </div>
        <div id="moves"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Chess game logic
        class ChessGame {
            constructor() {
                this.board = this.initBoard();
                this.turn = 'white';
                this.moves = [];
                this.gameOver = false;
            }

            initBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Pawns
                for (let i = 0; i < 8; i++) {
                    board[1][i] = { type: 'pawn', color: 'black' };
                    board[6][i] = { type: 'pawn', color: 'white' };
                }
                
                // Other pieces
                const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                for (let i = 0; i < 8; i++) {
                    board[0][i] = { type: backRow[i], color: 'black' };
                    board[7][i] = { type: backRow[i], color: 'white' };
                }
                
                return board;
            }

            getPossibleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece || piece.color !== this.turn) return [];

                const moves = [];
                
                switch(piece.type) {
                    case 'pawn':
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        if (this.isValid(row + direction, col) && !this.board[row + direction][col]) {
                            moves.push([row + direction, col]);
                            if (row === startRow && !this.board[row + 2 * direction][col]) {
                                moves.push([row + 2 * direction, col]);
                            }
                        }
                        
                        // Captures
                        [-1, 1].forEach(dc => {
                            if (this.isValid(row + direction, col + dc)) {
                                const target = this.board[row + direction][col + dc];
                                if (target && target.color !== piece.color) {
                                    moves.push([row + direction, col + dc]);
                                }
                            }
                        });
                        break;
                        
                    case 'knight':
                        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                        knightMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr, newCol = col + dc;
                            if (this.isValid(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || target.color !== piece.color) {
                                    moves.push([newRow, newCol]);
                                }
                            }
                        });
                        break;
                        
                    case 'bishop':
                        this.addLineMoves(moves, row, col, [[1,1],[1,-1],[-1,1],[-1,-1]]);
                        break;
                        
                    case 'rook':
                        this.addLineMoves(moves, row, col, [[1,0],[-1,0],[0,1],[0,-1]]);
                        break;
                        
                    case 'queen':
                        this.addLineMoves(moves, row, col, [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]);
                        break;
                        
                    case 'king':
                        const kingMoves = [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
                        kingMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr, newCol = col + dc;
                            if (this.isValid(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || target.color !== piece.color) {
                                    moves.push([newRow, newCol]);
                                }
                            }
                        });
                        break;
                }
                
                return moves;
            }

            addLineMoves(moves, row, col, directions) {
                const piece = this.board[row][col];
                directions.forEach(([dr, dc]) => {
                    let newRow = row + dr, newCol = col + dc;
                    while (this.isValid(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (!target) {
                            moves.push([newRow, newCol]);
                        } else {
                            if (target.color !== piece.color) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                        newRow += dr;
                        newCol += dc;
                    }
                });
            }

            isValid(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                const moveNotation = `${piece.color} ${piece.type} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
                this.moves.push(moveNotation);
                
                this.turn = this.turn === 'white' ? 'black' : 'white';
                
                if (captured && captured.type === 'king') {
                    this.gameOver = true;
                    return { gameOver: true, winner: piece.color };
                }
                
                return { gameOver: false, captured };
            }

            getAllPossibleMoves() {
                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === this.turn) {
                            const moves = this.getPossibleMoves(row, col);
                            moves.forEach(([toRow, toCol]) => {
                                allMoves.push({ from: [row, col], to: [toRow, toCol] });
                            });
                        }
                    }
                }
                return allMoves;
            }

            makeAIMove() {
                const possibleMoves = this.getAllPossibleMoves();
                if (possibleMoves.length === 0) {
                    this.gameOver = true;
                    return null;
                }
                
                // Simple AI: random move with slight preference for captures
                let bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                // Check for captures
                const captureMoves = possibleMoves.filter(move => {
                    const [toRow, toCol] = move.to;
                    return this.board[toRow][toCol] !== null;
                });
                
                if (captureMoves.length > 0 && Math.random() > 0.3) {
                    bestMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
                }
                
                return bestMove;
            }
        }

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 8, 5);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x4ecdc4, 1, 100);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);
        
        // Create chess board
        const boardSize = 8;
        const squareSize = 1;
        const pieces = {};
        
        function createBoard() {
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const isLight = (row + col) % 2 === 0;
                    const geometry = new THREE.BoxGeometry(squareSize, 0.2, squareSize);
                    const material = new THREE.MeshStandardMaterial({
                        color: isLight ? 0xeeeed2 : 0x769656,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    const square = new THREE.Mesh(geometry, material);
                    square.position.set(
                        col * squareSize - 3.5,
                        -0.1,
                        row * squareSize - 3.5
                    );
                    square.receiveShadow = true;
                    scene.add(square);
                }
            }
        }
        
        function createPiece(type, color, row, col) {
            let geometry;
            
            switch(type) {
                case 'pawn':
                    geometry = new THREE.CylinderGeometry(0.2, 0.3, 0.6, 8);
                    break;
                case 'rook':
                    geometry = new THREE.BoxGeometry(0.5, 0.8, 0.5);
                    break;
                case 'knight':
                    geometry = new THREE.ConeGeometry(0.3, 0.8, 4);
                    break;
                case 'bishop':
                    geometry = new THREE.ConeGeometry(0.25, 1, 8);
                    break;
                case 'queen':
                    geometry = new THREE.SphereGeometry(0.35, 8, 8);
                    break;
                case 'king':
                    geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 6);
                    break;
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color === 'white' ? 0xffffff : 0x333333,
                roughness: 0.5,
                metalness: 0.3
            });
            
            const piece = new THREE.Mesh(geometry, material);
            piece.position.set(
                col * squareSize - 3.5,
                0.5,
                row * squareSize - 3.5
            );
            piece.castShadow = true;
            piece.userData = { row, col, type, color };
            
            scene.add(piece);
            return piece;
        }
        
        function initPieces(game) {
            // Clear existing pieces
            Object.values(pieces).forEach(piece => scene.remove(piece));
            for (let key in pieces) delete pieces[key];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = game.board[row][col];
                    if (square) {
                        const key = `${row}-${col}`;
                        pieces[key] = createPiece(square.type, square.color, row, col);
                    }
                }
            }
        }
        
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const fromKey = `${fromRow}-${fromCol}`;
            const toKey = `${toRow}-${toCol}`;
            
            if (pieces[toKey]) {
                scene.remove(pieces[toKey]);
                delete pieces[toKey];
            }
            
            if (pieces[fromKey]) {
                pieces[fromKey].position.set(
                    toCol * squareSize - 3.5,
                    0.5,
                    toRow * squareSize - 3.5
                );
                pieces[toKey] = pieces[fromKey];
                pieces[toKey].userData.row = toRow;
                pieces[toKey].userData.col = toCol;
                delete pieces[fromKey];
            }
        }
        
        createBoard();
        
        const game = new ChessGame();
        initPieces(game);
        
        const statusDiv = document.getElementById('status');
        const movesDiv = document.getElementById('moves');
        
        let isPlaying = false;
        let moveInterval;
        
        function updateUI() {
            statusDiv.textContent = game.gameOver 
                ? `Game Over! ${game.turn === 'white' ? 'Black' : 'White'} wins!`
                : `${game.turn.charAt(0).toUpperCase() + game.turn.slice(1)}'s turn`;
            
            movesDiv.innerHTML = game.moves.slice(-10).reverse().map(move => 
                `<div class="move">${move}</div>`
            ).join('');
        }
        
        function playAIMove() {
            if (game.gameOver || !isPlaying) {
                clearInterval(moveInterval);
                return;
            }
            
            const move = game.makeAIMove();
            if (move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                movePiece(fromRow, fromCol, toRow, toCol);
                game.makeMove(fromRow, fromCol, toRow, toCol);
                updateUI();
            } else {
                isPlaying = false;
                clearInterval(moveInterval);
            }
        }
        
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isPlaying && !game.gameOver) {
                isPlaying = true;
                moveInterval = setInterval(playAIMove, 1000);
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isPlaying = false;
            clearInterval(moveInterval);
            game.board = game.initBoard();
            game.turn = 'white';
            game.moves = [];
            game.gameOver = false;
            initPieces(game);
            updateUI();
        });
        
        // Camera rotation
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            angle += 0.002;
            camera.position.x = Math.sin(angle) * 10;
            camera.position.z = Math.cos(angle) * 10;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        animate();
        updateUI();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
